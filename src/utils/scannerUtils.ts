import { ScanResult } from '../types/scanner';
import { fetchWithTimeout } from './fetchUtils';

export async function checkXSSVulnerability(url: string): Promise<ScanResult[]> {
  const results: ScanResult[] = [];
  try {
    const response = await fetchWithTimeout(url);
    const text = await response.text();
    
    // Common XSS patterns to check
    const xssPatterns = [
      '<script[^>]*>',
      'javascript:',
      'onerror=',
      'onload=',
      'onclick=',
      'data:text/html'
    ];
    
    const foundPatterns = xssPatterns.filter(pattern => 
      new RegExp(pattern, 'i').test(text)
    );
    
    if (foundPatterns.length > 0) {
      results.push({
        vulnerability: 'Cross-Site Scripting (XSS)',
        description: 'Potential XSS vulnerability detected',
        severity: 'High',
        url: url,
        details: `Found potentially unsafe patterns: ${foundPatterns.join(', ')}`
      });
    }
  } catch (error) {
    if (error instanceof Error) {
      results.push({
        vulnerability: 'Scan Error',
        description: 'Failed to check for XSS vulnerabilities',
        severity: 'Low',
        url: url,
        details: `Error: ${error.message}`
      });
    }
  }
  return results;
}

export async function checkSQLInjection(url: string): Promise<ScanResult[]> {
  const results: ScanResult[] = [];
  const testPayloads = ["'", "1' OR '1'='1", "1; DROP TABLE users"];
  
  try {
    for (const payload of testPayloads) {
      const testUrl = new URL(url);
      testUrl.searchParams.append('q', payload);
      
      const response = await fetchWithTimeout(testUrl.toString());
      const text = await response.text();
      
      const sqlErrorPatterns = [
        'sql',
        'database error',
        'ORA-',
        'MySQL',
        'SQL Server',
        'PostgreSQL'
      ];
      
      if (sqlErrorPatterns.some(pattern => text.toLowerCase().includes(pattern))) {
        results.push({
          vulnerability: 'SQL Injection',
          description: 'Potential SQL injection vulnerability detected',
          severity: 'Critical',
          url: url,
          details: `SQL error message exposed with payload: ${payload}`
        });
        break;
      }
    }
  } catch (error) {
    if (error instanceof Error) {
      results.push({
        vulnerability: 'Scan Error',
        description: 'Failed to check for SQL injection vulnerabilities',
        severity: 'Low',
        url: url,
        details: `Error: ${error.message}`
      });
    }
  }
  return results;
}

export async function checkSecurityHeaders(url: string): Promise<ScanResult[]> {
  const results: ScanResult[] = [];
  try {
    const response = await fetchWithTimeout(url);
    const headers = response.headers;
    
    const securityHeaders = {
      'Strict-Transport-Security': {
        message: 'Missing HSTS header',
        severity: 'High' as const
      },
      'X-Content-Type-Options': {
        message: 'Missing X-Content-Type-Options header',
        severity: 'Medium' as const
      },
      'X-Frame-Options': {
        message: 'Missing X-Frame-Options header',
        severity: 'Medium' as const
      },
      'Content-Security-Policy': {
        message: 'Missing Content Security Policy',
        severity: 'High' as const
      }
    };
    
    for (const [header, { message, severity }] of Object.entries(securityHeaders)) {
      if (!headers.get(header)) {
        results.push({
          vulnerability: 'Security Headers',
          description: message,
          severity,
          url: url,
          details: `The ${header} header is not set, which may expose the site to security risks`
        });
      }
    }
  } catch (error) {
    if (error instanceof Error) {
      results.push({
        vulnerability: 'Scan Error',
        description: 'Failed to check security headers',
        severity: 'Low',
        url: url,
        details: `Error: ${error.message}`
      });
    }
  }
  return results;
}